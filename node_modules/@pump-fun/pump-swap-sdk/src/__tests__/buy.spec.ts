import { expect } from "chai";
import BN from "bn.js";
import { clusterApiUrl, Connection, PublicKey } from "@solana/web3.js";
import { RawMint } from "@solana/spl-token";
import { buyBaseInputInternal } from "../sdk/buy";
import { createFeeConfigFromGlobalConfig } from "./utils";
import { Pool, GlobalConfig } from "../types/sdk";
import { PumpAmmSdk } from "../sdk/pumpAmm";

describe("buyBaseInput with fees", () => {
  const connection = new Connection(clusterApiUrl("devnet"), "confirmed");
  const sdk = new PumpAmmSdk(connection);
  const user = new PublicKey("4kBH5H5p9oRkZPGLSx8R4WKoDsmXnEpmzsgkebkKvzSg");

  const baseMintAccount: RawMint = {
    mintAuthorityOption: 0,
    mintAuthority: PublicKey.unique(),
    supply: BigInt(1),
    decimals: 9,
    isInitialized: false,
    freezeAuthorityOption: 0,
    freezeAuthority: PublicKey.unique(),
  };

  const pool: Pool = {
    poolBump: 1,
    index: 0,
    creator: PublicKey.unique(),
    baseMint: PublicKey.unique(),
    quoteMint: PublicKey.unique(),
    lpMint: PublicKey.unique(),
    poolBaseTokenAccount: PublicKey.unique(),
    poolQuoteTokenAccount: PublicKey.unique(),
    lpSupply: new BN(0),
    coinCreator: PublicKey.default,
  };

  const globalConfig: GlobalConfig = {
    admin: PublicKey.unique(),
    lpFeeBasisPoints: new BN(30),
    protocolFeeBasisPoints: new BN(20),
    disableFlags: 0,
    protocolFeeRecipients: [],
    coinCreatorFeeBasisPoints: new BN(0),
    adminSetCoinCreatorAuthority: PublicKey.unique(),
  };

  const feeConfig = createFeeConfigFromGlobalConfig(globalConfig);

  it("should compute quote + fees + slippage correctly", () => {
    // Example pool reserves
    const baseReserve = new BN(1_000_000);
    const quoteReserve = new BN(2_000_000);

    // Request to buy 10,000 base tokens
    const base = new BN(10_000);

    // Slippage = 1% (slippage=1 => 1%)
    const slippage = 1;

    const result = buyBaseInputInternal({
      base,
      slippage,
      baseReserve,
      quoteReserve,
      globalConfig,
      baseMintAccount,
      baseMint: pool.baseMint,
      coinCreator: pool.coinCreator,
      creator: pool.creator,
      feeConfig,
    });

    console.log("quote =", result.uiQuote.toString());
    console.log("maxQuote =", result.maxQuote.toString());

    // You can calculate offline and replace these with your
    // actual expected values:
    const expectedQuote = new BN(20305); // Example only
    const expectedMaxQuote = new BN(20508); // Example only

    expect(result.uiQuote.toString()).eq(expectedQuote.toString());
    expect(result.maxQuote.toString()).eq(expectedMaxQuote.toString());
  });

  it("should fail if base > baseReserve", () => {
    const baseReserve = new BN(1_000_000);
    const quoteReserve = new BN(2_000_000);
    const base = new BN(2_000_000); // more than pool
    const slippage = 1;

    expect(() =>
      buyBaseInputInternal({
        base,
        slippage,
        baseReserve,
        quoteReserve,
        globalConfig,
        baseMintAccount,
        baseMint: pool.baseMint,
        coinCreator: pool.coinCreator,
        creator: pool.creator,
        feeConfig,
      }),
    ).to.throw("Cannot buy more base tokens than the pool reserves.");
  });

  it("should build the instruction successfully", async () => {
    const pool = new PublicKey("Fzrac7XDX29dYBfMeoPBG18zB2BYFxR5v9fV9zFH7fnV");

    expect(async () => {
      return await sdk.buyBaseInput(
        await sdk.swapSolanaState(pool, user),
        new BN(10),
        10,
      );
    }).to.not.throw();
  });
});
